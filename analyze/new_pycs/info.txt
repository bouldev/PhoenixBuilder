
ASTFromString: import sys
PyCompile
ASTFromString: import _functools
PyCompile
ASTFromString: print 'Python', sys.version_info
PyCompile
ASTFromString: print sys.path
PyCompile
ASTFromString: print sys.path
PyCompile
ASTFromString: print sys.path
PyCompile
ASTFromString: def __str__(self):
  return self.args and ('%s' % self.args[0]) or '(what)'

PyCompile
ASTFromString: def __str__(self):
  a=self.args
  a=a and type(a[0]) or '(what)'
  return 'Cannot pickle %s objects' % a

PyCompile
ASTFromString: class ProtocalType(tuple):
    'ProtocalType(code, magic)'

    __slots__ = ()

    _fields = ('code', 'magic')

    def __new__(_cls, code, magic):
        'Create new instance of ProtocalType(code, magic)'
        return _tuple.__new__(_cls, (code, magic))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new ProtocalType object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 2:
            raise TypeError('Expected 2 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'ProtocalType(code=%r, magic=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new ProtocalType object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('code', 'magic'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    code = _property(_itemgetter(0), doc='Alias for field number 0')

    magic = _property(_itemgetter(1), doc='Alias for field number 1')


PyCompile
ASTFromString: class Attribute(tuple):
    'Attribute(name, kind, defining_class, object)'

    __slots__ = ()

    _fields = ('name', 'kind', 'defining_class', 'object')

    def __new__(_cls, name, kind, defining_class, object):
        'Create new instance of Attribute(name, kind, defining_class, object)'
        return _tuple.__new__(_cls, (name, kind, defining_class, object))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new Attribute object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 4:
            raise TypeError('Expected 4 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'Attribute(name=%r, kind=%r, defining_class=%r, object=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new Attribute object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('name', 'kind', 'defining_class', 'object'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    name = _property(_itemgetter(0), doc='Alias for field number 0')

    kind = _property(_itemgetter(1), doc='Alias for field number 1')

    defining_class = _property(_itemgetter(2), doc='Alias for field number 2')

    object = _property(_itemgetter(3), doc='Alias for field number 3')


PyCompile
ASTFromString: class ModuleInfo(tuple):
    'ModuleInfo(name, suffix, mode, module_type)'

    __slots__ = ()

    _fields = ('name', 'suffix', 'mode', 'module_type')

    def __new__(_cls, name, suffix, mode, module_type):
        'Create new instance of ModuleInfo(name, suffix, mode, module_type)'
        return _tuple.__new__(_cls, (name, suffix, mode, module_type))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new ModuleInfo object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 4:
            raise TypeError('Expected 4 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'ModuleInfo(name=%r, suffix=%r, mode=%r, module_type=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new ModuleInfo object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('name', 'suffix', 'mode', 'module_type'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    name = _property(_itemgetter(0), doc='Alias for field number 0')

    suffix = _property(_itemgetter(1), doc='Alias for field number 1')

    mode = _property(_itemgetter(2), doc='Alias for field number 2')

    module_type = _property(_itemgetter(3), doc='Alias for field number 3')


PyCompile
ASTFromString: class Arguments(tuple):
    'Arguments(args, varargs, keywords)'

    __slots__ = ()

    _fields = ('args', 'varargs', 'keywords')

    def __new__(_cls, args, varargs, keywords):
        'Create new instance of Arguments(args, varargs, keywords)'
        return _tuple.__new__(_cls, (args, varargs, keywords))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new Arguments object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 3:
            raise TypeError('Expected 3 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'Arguments(args=%r, varargs=%r, keywords=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new Arguments object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('args', 'varargs', 'keywords'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    args = _property(_itemgetter(0), doc='Alias for field number 0')

    varargs = _property(_itemgetter(1), doc='Alias for field number 1')

    keywords = _property(_itemgetter(2), doc='Alias for field number 2')


PyCompile
ASTFromString: class ArgSpec(tuple):
    'ArgSpec(args, varargs, keywords, defaults)'

    __slots__ = ()

    _fields = ('args', 'varargs', 'keywords', 'defaults')

    def __new__(_cls, args, varargs, keywords, defaults):
        'Create new instance of ArgSpec(args, varargs, keywords, defaults)'
        return _tuple.__new__(_cls, (args, varargs, keywords, defaults))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new ArgSpec object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 4:
            raise TypeError('Expected 4 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'ArgSpec(args=%r, varargs=%r, keywords=%r, defaults=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new ArgSpec object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('args', 'varargs', 'keywords', 'defaults'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    args = _property(_itemgetter(0), doc='Alias for field number 0')

    varargs = _property(_itemgetter(1), doc='Alias for field number 1')

    keywords = _property(_itemgetter(2), doc='Alias for field number 2')

    defaults = _property(_itemgetter(3), doc='Alias for field number 3')


PyCompile
ASTFromString: class ArgInfo(tuple):
    'ArgInfo(args, varargs, keywords, locals)'

    __slots__ = ()

    _fields = ('args', 'varargs', 'keywords', 'locals')

    def __new__(_cls, args, varargs, keywords, locals):
        'Create new instance of ArgInfo(args, varargs, keywords, locals)'
        return _tuple.__new__(_cls, (args, varargs, keywords, locals))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new ArgInfo object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 4:
            raise TypeError('Expected 4 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'ArgInfo(args=%r, varargs=%r, keywords=%r, locals=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new ArgInfo object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('args', 'varargs', 'keywords', 'locals'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    args = _property(_itemgetter(0), doc='Alias for field number 0')

    varargs = _property(_itemgetter(1), doc='Alias for field number 1')

    keywords = _property(_itemgetter(2), doc='Alias for field number 2')

    locals = _property(_itemgetter(3), doc='Alias for field number 3')


PyCompile
ASTFromString: class Traceback(tuple):
    'Traceback(filename, lineno, function, code_context, index)'

    __slots__ = ()

    _fields = ('filename', 'lineno', 'function', 'code_context', 'index')

    def __new__(_cls, filename, lineno, function, code_context, index):
        'Create new instance of Traceback(filename, lineno, function, code_context, index)'
        return _tuple.__new__(_cls, (filename, lineno, function, code_context, index))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new Traceback object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 5:
            raise TypeError('Expected 5 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'Traceback(filename=%r, lineno=%r, function=%r, code_context=%r, index=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new Traceback object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('filename', 'lineno', 'function', 'code_context', 'index'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    filename = _property(_itemgetter(0), doc='Alias for field number 0')

    lineno = _property(_itemgetter(1), doc='Alias for field number 1')

    function = _property(_itemgetter(2), doc='Alias for field number 2')

    code_context = _property(_itemgetter(3), doc='Alias for field number 3')

    index = _property(_itemgetter(4), doc='Alias for field number 4')


PyCompile
ASTFromString: class SplitResult(tuple):
    'SplitResult(scheme, netloc, path, query, fragment)'

    __slots__ = ()

    _fields = ('scheme', 'netloc', 'path', 'query', 'fragment')

    def __new__(_cls, scheme, netloc, path, query, fragment):
        'Create new instance of SplitResult(scheme, netloc, path, query, fragment)'
        return _tuple.__new__(_cls, (scheme, netloc, path, query, fragment))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new SplitResult object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 5:
            raise TypeError('Expected 5 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'SplitResult(scheme=%r, netloc=%r, path=%r, query=%r, fragment=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new SplitResult object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('scheme', 'netloc', 'path', 'query', 'fragment'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    scheme = _property(_itemgetter(0), doc='Alias for field number 0')

    netloc = _property(_itemgetter(1), doc='Alias for field number 1')

    path = _property(_itemgetter(2), doc='Alias for field number 2')

    query = _property(_itemgetter(3), doc='Alias for field number 3')

    fragment = _property(_itemgetter(4), doc='Alias for field number 4')


PyCompile
ASTFromString: class ParseResult(tuple):
    'ParseResult(scheme, netloc, path, params, query, fragment)'

    __slots__ = ()

    _fields = ('scheme', 'netloc', 'path', 'params', 'query', 'fragment')

    def __new__(_cls, scheme, netloc, path, params, query, fragment):
        'Create new instance of ParseResult(scheme, netloc, path, params, query, fragment)'
        return _tuple.__new__(_cls, (scheme, netloc, path, params, query, fragment))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new ParseResult object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 6:
            raise TypeError('Expected 6 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'ParseResult(scheme=%r, netloc=%r, path=%r, params=%r, query=%r, fragment=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new ParseResult object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('scheme', 'netloc', 'path', 'params', 'query', 'fragment'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    scheme = _property(_itemgetter(0), doc='Alias for field number 0')

    netloc = _property(_itemgetter(1), doc='Alias for field number 1')

    path = _property(_itemgetter(2), doc='Alias for field number 2')

    params = _property(_itemgetter(3), doc='Alias for field number 3')

    query = _property(_itemgetter(4), doc='Alias for field number 4')

    fragment = _property(_itemgetter(5), doc='Alias for field number 5')


PyCompile
ASTFromString: class ExtType(tuple):
    'ExtType(code, data)'

    __slots__ = ()

    _fields = ('code', 'data')

    def __new__(_cls, code, data):
        'Create new instance of ExtType(code, data)'
        return _tuple.__new__(_cls, (code, data))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new ExtType object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 2:
            raise TypeError('Expected 2 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'ExtType(code=%r, data=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new ExtType object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('code', 'data'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    code = _property(_itemgetter(0), doc='Alias for field number 0')

    data = _property(_itemgetter(1), doc='Alias for field number 1')


PyCompile
ASTFromString: class DecimalTuple(tuple):
    'DecimalTuple(sign, digits, exponent)'

    __slots__ = ()

    _fields = ('sign', 'digits', 'exponent')

    def __new__(_cls, sign, digits, exponent):
        'Create new instance of DecimalTuple(sign, digits, exponent)'
        return _tuple.__new__(_cls, (sign, digits, exponent))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new DecimalTuple object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 3:
            raise TypeError('Expected 3 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'DecimalTuple(sign=%r, digits=%r, exponent=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new DecimalTuple object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('sign', 'digits', 'exponent'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    sign = _property(_itemgetter(0), doc='Alias for field number 0')

    digits = _property(_itemgetter(1), doc='Alias for field number 1')

    exponent = _property(_itemgetter(2), doc='Alias for field number 2')


PyCompile
ASTFromString: exec _code_ in _globs_, _locs_
PyCompile
ASTFromString: def reraise(tp, value, tb=None):
    raise tp, value, tb

PyCompile
ASTFromString: class EditMode(tuple):
    'EditMode(Mode, ActionName, Text)'

    __slots__ = ()

    _fields = ('Mode', 'ActionName', 'Text')

    def __new__(_cls, Mode, ActionName, Text):
        'Create new instance of EditMode(Mode, ActionName, Text)'
        return _tuple.__new__(_cls, (Mode, ActionName, Text))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new EditMode object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 3:
            raise TypeError('Expected 3 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'EditMode(Mode=%r, ActionName=%r, Text=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new EditMode object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('Mode', 'ActionName', 'Text'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    Mode = _property(_itemgetter(0), doc='Alias for field number 0')

    ActionName = _property(_itemgetter(1), doc='Alias for field number 1')

    Text = _property(_itemgetter(2), doc='Alias for field number 2')


PyCompile
ASTFromString: class CreateEntityData(tuple):
    'CreateEntityData(ActionName, EntityType, Text, PrefabData, EditGroup)'

    __slots__ = ()

    _fields = ('ActionName', 'EntityType', 'Text', 'PrefabData', 'EditGroup')

    def __new__(_cls, ActionName, EntityType, Text, PrefabData, EditGroup):
        'Create new instance of CreateEntityData(ActionName, EntityType, Text, PrefabData, EditGroup)'
        return _tuple.__new__(_cls, (ActionName, EntityType, Text, PrefabData, EditGroup))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new CreateEntityData object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 5:
            raise TypeError('Expected 5 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'CreateEntityData(ActionName=%r, EntityType=%r, Text=%r, PrefabData=%r, EditGroup=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new CreateEntityData object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('ActionName', 'EntityType', 'Text', 'PrefabData', 'EditGroup'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    ActionName = _property(_itemgetter(0), doc='Alias for field number 0')

    EntityType = _property(_itemgetter(1), doc='Alias for field number 1')

    Text = _property(_itemgetter(2), doc='Alias for field number 2')

    PrefabData = _property(_itemgetter(3), doc='Alias for field number 3')

    EditGroup = _property(_itemgetter(4), doc='Alias for field number 4')


PyCompile
ASTFromString: class IconName(tuple):
    'IconName(Avatar, PlayerAvatar, Monster, NPC, Spawn, Radar, Pet, Carrier, Other)'

    __slots__ = ()

    _fields = ('Avatar', 'PlayerAvatar', 'Monster', 'NPC', 'Spawn', 'Radar', 'Pet', 'Carrier', 'Other')

    def __new__(_cls, Avatar, PlayerAvatar, Monster, NPC, Spawn, Radar, Pet, Carrier, Other):
        'Create new instance of IconName(Avatar, PlayerAvatar, Monster, NPC, Spawn, Radar, Pet, Carrier, Other)'
        return _tuple.__new__(_cls, (Avatar, PlayerAvatar, Monster, NPC, Spawn, Radar, Pet, Carrier, Other))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new IconName object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 9:
            raise TypeError('Expected 9 arguments, got %d' % len(result))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return 'IconName(Avatar=%r, PlayerAvatar=%r, Monster=%r, NPC=%r, Spawn=%r, Radar=%r, Pet=%r, Carrier=%r, Other=%r)' % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their values'
        return OrderedDict(zip(self._fields, self))

    def _replace(_self, **kwds):
        'Return a new IconName object replacing specified fields with new values'
        result = _self._make(map(kwds.pop, ('Avatar', 'PlayerAvatar', 'Monster', 'NPC', 'Spawn', 'Radar', 'Pet', 'Carrier', 'Other'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' % kwds.keys())
        return result

    def __getnewargs__(self):
        'Return self as a plain tuple.  Used by copy and pickle.'
        return tuple(self)

    __dict__ = _property(_asdict)

    def __getstate__(self):
        'Exclude the OrderedDict from pickling'
        pass

    Avatar = _property(_itemgetter(0), doc='Alias for field number 0')

    PlayerAvatar = _property(_itemgetter(1), doc='Alias for field number 1')

    Monster = _property(_itemgetter(2), doc='Alias for field number 2')

    NPC = _property(_itemgetter(3), doc='Alias for field number 3')

    Spawn = _property(_itemgetter(4), doc='Alias for field number 4')

    Radar = _property(_itemgetter(5), doc='Alias for field number 5')

    Pet = _property(_itemgetter(6), doc='Alias for field number 6')

    Carrier = _property(_itemgetter(7), doc='Alias for field number 7')

    Other = _property(_itemgetter(8), doc='Alias for field number 8')


PyCompile
ASTFromString: # coding=utf-8

# -*- coding:utf-8 -*-
import sys

import _qsechelper
import QSecImp
checklist = [('libminecraftpe.so', 'gladLoadGLES2Loader',0x389F46d,0x03744B04,0x3a83126f), ('libminecraftpe.so', '_ZN14ButtonRepeaterC2Ev',0x02C1CCA9,0x0231318C,0x3f7ae148), ('libminecraftpe.so', '_ZN8GGDeviceC2Ev',0x2c224d1,0x01EB23A4,0x3A83126f), ('libminecraftpe.so', '_ZN20GameControllerMapperC2Ev',0x02c25bb9,0x01EC9E34,0x4ff0e92d), ('libminecraftpe.so', '_ZN14ButtonRepeaterC2Ev',0x02C1CCA9,0x01BF3254,0x0b0a7b5f0), ('libminecraftpe.so', 'ANativeActivity_onCreate',0x0ae0fcd,0x0f5cee0,0x47f0e92d), ('libminecraftpe.so', '_ZN19CrashDumpGlobalData11setPlatformEPKc',0x394b75d,0x2400b48,0x4ff0e92d), ('libminecraftpe.so', '_ZNK14ResourceLoader7getPathERK16ResourceLocation',0x391f495,0x24427e0,0x4604b570)]
import record
if record.get_engine_version()=='1.24.0.140642':QSecImp.getInstance().InitQsecData(checklist)
PyCompile
ASTFromString: # coding=utf-8

# -*- coding:utf-8 -*-
import sys

import _qsechelper
import QSecImp
checklist = [('libminecraftpe.so', 'gladLoadGLES2Loader',0x389F46d,0x03744B04,0x3a83126f), ('libminecraftpe.so', '_ZN14ButtonRepeaterC2Ev',0x02C1CCA9,0x0231318C,0x3f7ae148), ('libminecraftpe.so', '_ZN8GGDeviceC2Ev',0x2c224d1,0x01EB23A4,0x3A83126f), ('libminecraftpe.so', '_ZN20GameControllerMapperC2Ev',0x02c25bb9,0x01EC9E34,0x4ff0e92d), ('libminecraftpe.so', '_ZN14ButtonRepeaterC2Ev',0x02C1CCA9,0x01BF3254,0x0b0a7b5f0), ('libminecraftpe.so', 'ANativeActivity_onCreate',0x0ae0fcd,0x0f5cee0,0x47f0e92d), ('libminecraftpe.so', '_ZN19CrashDumpGlobalData11setPlatformEPKc',0x394b75d,0x2400b48,0x4ff0e92d), ('libminecraftpe.so', '_ZNK14ResourceLoader7getPathERK16ResourceLocation',0x391f495,0x24427e0,0x4604b570)]
import record
if record.get_engine_version()=='1.24.5.141246':QSecImp.getInstance().InitQsecData(checklist)
PyCompile